function gridSome(grid,func){return grid.some((row,rowNum)=>{return row.some((cell,colNum)=>{return func(cell,rowNum,colNum)})})}function gridForEach(grid,func){grid.forEach((row,rowNum)=>{row.forEach((cell,colNum)=>{func(cell,rowNum,colNum)})})}const BOARD_WIDTH=10;const BOARD_HEIGHT=40;const BUFFER_ZONE_HEIGHT=20;const CELL_SIZE=30;const NEXT_SIZE=6;const MAX_LEVEL=15;const FIXED_GOAL=10;const AUTO_REPEAT_FREQ=50;const AUTO_REPEAT_DELAY=300;const LOCKDOWN_TIME=500;const LOCKDOWN_MOVE_LIMIT=15;const LEFT_MARGIN=8*CELL_SIZE;const RIGHT_MARGIN=8*CELL_SIZE;const DIRECTION={NONE:0,LEFT:1,RIGHT:2,UP:3,DOWN:4,CLOCKWISE:5,ANTI_CLOCKWISE:6};const COLOUR={WHITE:[255,255,255],RED:[209,41,0],ORANGE:[209,121,0],YELLOW:[209,205,0],GREEN:[0,209,66],LIGHT_BLUE:[0,209,209],BLUE:[0,62,209],PURPLE:[128,0,209],MAGENTA:[255,0,255],NIGHT:[34,34,41]};const KEY={S:"S".charCodeAt(0),A:"A".charCodeAt(0),D:"D".charCodeAt(0),Q:"Q".charCodeAt(0),E:"E".charCodeAt(0),R:"R".charCodeAt(0),C:"C".charCodeAt(0),P:"P".charCodeAt(0),SPACE:" ".charCodeAt(0)};const STATE={NONE:0,MENU:1,PAUSED:2,PLAYING:3,GAME_OVER:4};const MOVE={NONE:0,TSPIN:1,TSPIN_MINI:2};class Tetro{constructor(colour,grid,srsObj){this.rotations=[];this.colour=colour;this.rotations[0]=grid;const rotateGrid=function(grid,direction){const newGrid=[];const oldWidth=grid[0].length;const oldHeight=grid.length;for(let y=0;y<oldWidth;++y){const newRow=[];for(let x=0;x<oldHeight;++x){if(direction==DIRECTION.CLOCKWISE){newRow[x]=grid[oldHeight-x-1][y]}else{newRow[x]=grid[x][oldWidth-y-1]}}newGrid[y]=newRow}return newGrid};for(let i=0;i<3;++i){this.rotations.push(rotateGrid(this.rotations[i],DIRECTION.CLOCKWISE))}this.rotations[0].points=srsObj.NORTH;this.rotations[1].points=srsObj.EAST;this.rotations[2].points=srsObj.SOUTH;this.rotations[3].points=srsObj.WEST}}class ActiveTetro{constructor(tetro=TETRO.iShape){this.tetro=tetro;this.pos={row:19,col:BOARD_WIDTH/2-1};this.orientation=0;this.grid=this.tetro.rotations[this.orientation];if(this.tetro==TETRO.iShape){this.pos.col=BOARD_WIDTH/2-2}}}class TetroBag{constructor(){this.bag=[];this.fillBag()}fillBag(){this.bag=Object.values(TETRO);for(let i=this.bag.length-1;i>0;--i){const r=Math.floor(Math.random()*i);[this.bag[i],this.bag[r]]=[this.bag[r],this.bag[i]]}}take(){if(this.bag.length===0){this.fillBag()}return this.bag.shift()}}class SRSPoint{constructor(rowOffset,colOffset){this.row=rowOffset;this.col=colOffset}}const TETRO={iShape:new Tetro(COLOUR.LIGHT_BLUE,[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],{NORTH:[[1,0],[1,3],[1,0],[1,3]],EAST:[[1,2],[1,2],[0,2],[3,2]],SOUTH:[[1,3],[1,0],[2,3],[2,0]],WEST:[[1,1],[1,1],[3,1],[0,1]]}),jShape:new Tetro(COLOUR.BLUE,[[1,0,0],[1,1,1],[0,0,0]],{NORTH:[[1,1],[1,1],[1,1],[1,1]],EAST:[[1,2],[2,2],[-1,1],[-1,-2]],SOUTH:[[1,1],[1,1],[1,1],[1,1]],WEST:[[0,1],[2,0],[-1,1],[-1,0]]}),lShape:new Tetro(COLOUR.ORANGE,[[0,0,1],[1,1,1],[0,0,0]],{NORTH:[[1,1],[1,1],[1,1],[1,1]],EAST:[[1,2],[2,2],[-1,1],[-1,2]],SOUTH:[[1,1],[1,1],[1,1],[1,1]],WEST:[[1,0],[2,0],[-1,1],[-1,0]]}),oShape:new Tetro(COLOUR.YELLOW,[[1,1],[1,1]],{NORTH:[[1,1],[1,1],[1,1],[1,1]],EAST:[[1,1],[1,1],[1,1],[1,1]],SOUTH:[[1,1],[1,1],[1,1],[1,1]],WEST:[[1,1],[1,1],[1,1],[1,1]]}),sShape:new Tetro(COLOUR.GREEN,[[0,1,1],[1,1,0],[0,0,0]],{NORTH:[[1,1],[1,1],[1,1],[1,1]],EAST:[[1,2],[2,2],[-1,1],[-1,2]],SOUTH:[[1,1],[1,1],[1,1],[1,1]],WEST:[[1,0],[2,0],[-1,1],[-1,0]]}),tShape:new Tetro(COLOUR.PURPLE,[[0,1,0],[1,1,1],[0,0,0]],{NORTH:[[1,1],[1,1],[1,1],[1,1]],EAST:[[1,2],[2,2],[-1,1],[-1,2]],SOUTH:[[1,1],[1,1],[1,1],[1,1]],WEST:[[1,0],[2,0],[-1,1],[-1,0]]}),zShape:new Tetro(COLOUR.RED,[[1,1,0],[0,1,1],[0,0,0]],{NORTH:[[1,1],[1,1],[1,1],[1,1]],EAST:[[1,2],[2,2],[-1,1],[-1,2]],SOUTH:[[1,1],[1,1],[1,1],[1,1]],WEST:[[1,0],[2,0],[-1,1],[-1,0]]})};function getTPoints(orientation){let p=[[0,0],[0,2],[2,2],[2,0]];for(let i=0;i<orientation;++i){[p[0],p[1],p[2],p[3]]=[p[1],p[2],p[3],p[0]]}return p}const TPOINTS=[getTPoints(0),getTPoints(1),getTPoints(2),getTPoints(3)];function checkTPoints(board,pos,orientation){const tPoints=TPOINTS[orientation];const freePoints=[];TPOINTS[orientation].forEach((tPoint,index)=>{const row=pos.row+tPoint[0];const col=pos.col+tPoint[1];freePoints[index]=!board[row]||board[row][col]!=0});return freePoints}class Game{constructor(){this.gameOver=false;this.ghostOffset=0;this.tetroBag=new TetroBag;this.next=[];this.holdSlot=null;this.score=0;this.moveData={move:MOVE.NONE,rows:0,backToBack:false};this.backToBackStarted=false;this.level=1;this.goal=5;this.fallTime=1;this.softDropping=false;this.stats={rowsCleared:0,tetrises:0,tSpins:0,tSpinMinis:0};this.initBoard();this.initNext();this.nextTetro()}initBoard(){this.board=[];for(let y=0;y<BOARD_HEIGHT;++y){const row=[];for(let x=0;x<BOARD_WIDTH;++x){row.push(0)}this.board.push(row)}}initNext(){for(let i=0;i<NEXT_SIZE;++i){this.next.push(this.tetroBag.take())}}fall(){let newObject=null;if(!this.move(DIRECTION.DOWN)){this.lockdown();newObject={};Object.assign(newObject,this.moveData);this.moveData.move=MOVE.NONE;this.moveData.rows=0;this.moveData.backToBack=0}return newObject}hardDrop(){this.score+=2*this.ghostOffset;this.activeTetro.pos.row+=this.ghostOffset;this.ghostOffset=0;return this.fall()}calculateFallSpeed(){this.fallTime=Math.pow(.8-(this.level-1)*.007,this.level-1)}isPieceOnSurface(){return this.ghostOffset==0}lockdown(){this.placeTetro();let rowClears=this.clearFullRows();this.moveData.rows=rowClears;let moveScore=0;let backToBack=false;switch(this.moveData.move){case MOVE.NONE:moveScore=[0,100,300,500,800][rowClears];if(rowClears==4){backToBack=true;++this.stats.tetrises}break;case MOVE.TSPIN_MINI:moveScore=[100,200][rowClears];++this.stats.tSpinMinis;backToBack=true;break;case MOVE.TSPIN:moveScore=[400,800,1200,1600][rowClears];++this.stats.tSpins;backToBack=true;break}let awardedRowClears=Math.floor(moveScore/100);if(rowClears>0){this.moveData.backToBack=this.backToBackStarted&&backToBack;if(this.moveData.backToBack){awardedRowClears=Math.floor(awardedRowClears*1.5);moveScore=Math.floor(moveScore*1.5)}this.backToBackStarted=backToBack}this.score+=moveScore*this.level;this.stats.rowsCleared+=awardedRowClears;this.nextTetro();if(this.stats.rowsCleared>=this.goal){++this.level;this.goal+=this.level*5;this.calculateFallSpeed();if(this.level>MAX_LEVEL){this.level=maxLevel;this.gameOver=true}}}handleMove(){}tetroFitsOnBoard(tetroGrid,rowPos,colPos){return!gridSome(tetroGrid,(cell,r,c)=>{let cellFree=true;if(cell){const row=this.board[r+rowPos];cellFree=row&&row[c+colPos]===0}return!cellFree})}calculateGhostOffset(){const pos=this.activeTetro.pos;this.ghostOffset=0;while(this.tetroFitsOnBoard(this.activeTetro.grid,pos.row+this.ghostOffset+1,pos.col)){++this.ghostOffset}}clearRow(rowNum){for(let r=rowNum;r>=0;--r){const row=this.board[r];row.forEach((cell,cellNum)=>{let newVal=0;if(r!=0){newVal=this.board[r-1][cellNum]}this.board[r][cellNum]=newVal})}}clearFullRows(){let rowsCleared=0;this.board.forEach((row,rowNum)=>{const emptyFound=row.some(cell=>cell==0);if(!emptyFound){this.clearRow(rowNum);++rowsCleared}});return rowsCleared}nextTetro(){const newTetro=new ActiveTetro(this.next.shift());this.next.push(this.tetroBag.take());if(this.tetroFitsOnBoard(newTetro.tetro.rotations[0],newTetro.pos.row,newTetro.pos.col)){this.activeTetro=newTetro}else{this.gameOver=true}this.calculateGhostOffset();this.canHold=true}holdTetro(){const success=this.canHold;if(this.canHold){if(this.holdSlot){[this.holdSlot,this.activeTetro]=[this.activeTetro.tetro,new ActiveTetro(this.holdSlot)];this.calculateGhostOffset()}else{this.holdSlot=this.activeTetro.tetro;this.nextTetro()}this.canHold=false}return success}spin(direction){const thisTetro=this.activeTetro;const pos=thisTetro.pos;let spinPossible=false;let newOrientation=thisTetro.orientation;if(direction===DIRECTION.CLOCKWISE){newOrientation=(newOrientation+1)%4}else if(direction===DIRECTION.ANTI_CLOCKWISE){newOrientation=(newOrientation-1)%4}const spunGrid=this.activeTetro.tetro.rotations[newOrientation];const oldPoints=thisTetro.tetro.rotations[thisTetro.orientation].points;const newPoints=thisTetro.tetro.rotations[newOrientation].points;let rowTranslate=0;let colTranslate=0;let pointCounter=0;spinPossible=this.tetroFitsOnBoard(spunGrid,pos.row,pos.col);while(!spinPossible&&pointCounter<4){const oldPoint=oldPoints[pointCounter];const newPoint=newPoints[pointCounter];rowTranslate=oldPoint[0]-newPoint[0];colTranslate=oldPoint[1]-newPoint[1];spinPossible=this.tetroFitsOnBoard(spunGrid,pos.row+rowTranslate,pos.col+colTranslate);++pointCounter}if(spinPossible){thisTetro.pos.row+=rowTranslate;thisTetro.pos.col+=colTranslate;thisTetro.orientation=newOrientation;thisTetro.grid=spunGrid;if(this.activeTetro.tetro==TETRO.tShape){const[A,B,C,D]=checkTPoints(this.board,thisTetro.pos,newOrientation);if(pointCounter==3||A&&B&&(C||D)){this.moveData.move=MOVE.TSPIN}else if(C&&D&&(A||B)){this.moveData.move=MOVE.TSPIN_MINI}}}this.calculateGhostOffset();return spinPossible}move(direction){let rowNum=this.activeTetro.pos.row;let colNum=this.activeTetro.pos.col;let success=false;switch(direction){case DIRECTION.LEFT:--colNum;break;case DIRECTION.RIGHT:++colNum;break;case DIRECTION.DOWN:if(this.softDropping){++this.score}++rowNum;break}if(direction!=DIRECTION.DOWN){success=this.tetroFitsOnBoard(this.activeTetro.grid,rowNum,colNum)}else{if(this.ghostOffset!=0){success=true;--this.ghostOffset}}if(success){this.activeTetro.pos.row=rowNum;this.activeTetro.pos.col=colNum;this.calculateGhostOffset()}return success}placeTetro(){gridForEach(this.activeTetro.grid,(cell,r,c)=>{if(cell){const rowPos=r+this.activeTetro.pos.row;const colPos=c+this.activeTetro.pos.col;const colour=this.activeTetro.tetro.colour;const colourIndex=Object.values(COLOUR).indexOf(colour);this.board[rowPos][colPos]=colourIndex}})}}document.addEventListener("visibilitychange",function(){if(state==STATE.PLAYING){state=STATE.PAUSED}});window.addEventListener("keydown",function(e){if([32,37,38,39,40].indexOf(e.keyCode)>-1){e.preventDefault()}},false);const XLARGE=80;const LARGE=65;const MEDIUM=50;const SMALL=35;let lastFallTime=0;let lastFrameDrawTime=0;let state=STATE.MENU;let displayScore=0;let currentTime=0;let game=null;const autoRepeats=[];let autoRepeatStartTime=0;let lastAutoRepeatTime=0;let lockdownTimer=0;let lockdownCounter=0;let lockdownStarted=false;let lockdownRow=0;let font=null;let lastMove="";function preload(){font=loadFont("./resources/CT ProLamina.ttf")}function setup(){const canvas=createCanvas(CELL_SIZE*BOARD_WIDTH+LEFT_MARGIN+RIGHT_MARGIN,CELL_SIZE*(BOARD_HEIGHT-BUFFER_ZONE_HEIGHT));canvas.parent("game");textFont(font);stroke("#444");lastFallTime=millis();game=new Game}function draw(){currentTime=Math.floor(millis());const frameTime=currentTime-lastFrameDrawTime;lastFrameDrawTime+=frameTime;if(displayScore<game.score){displayScore+=frameTime*game.level;if(displayScore>game.score){displayScore=game.score}}switch(state){case STATE.MENU:drawMenu();break;case STATE.PLAYING:autoRepeat(currentTime);const timeSinceLastFall=lastFrameDrawTime-lastFallTime;let fallTime=game.fallTime*1e3/(game.softDropping?20:1);if(lockdownStarted){lockdownTimer+=frameTime;if(!game.isPieceOnSurface()&&game.activeTetro.pos.row>lockdownRow){lockdownStarted=false}}if(game.gameOver){state=STATE.GAME_OVER}else if(lockdownStarted){if(lockdownTimer>=LOCKDOWN_TIME||lockdownCounter>=LOCKDOWN_MOVE_LIMIT){handleMoveData(game.fall());lockdownStarted=false;lastFallTime=lastFrameDrawTime}}else if(timeSinceLastFall>=fallTime){handleMoveData(game.fall());checkLockdown();lastFallTime=lastFrameDrawTime}drawGame();break;case STATE.PAUSED:drawPauseMenu();break;case STATE.GAME_OVER:drawEndScreen();break}}function keyPressed(){const annoyingKeys=[KEY.SPACE,UP_ARROW,DOWN_ARROW];let returnVal=!annoyingKeys.includes(keyCode);if(state==STATE.PLAYING){switch(keyCode){case KEY.A:case LEFT_ARROW:game.move(DIRECTION.LEFT);autoRepeats.unshift(DIRECTION.LEFT);autoRepeatStartTime=currentTime;checkLockdown();break;case KEY.D:case RIGHT_ARROW:game.move(DIRECTION.RIGHT);autoRepeats.unshift(DIRECTION.RIGHT);autoRepeatStartTime=currentTime;checkLockdown();break;case KEY.S:case DOWN_ARROW:game.softDropping=true;break;case KEY.E:case KEY.W:case UP_ARROW:game.spin(DIRECTION.CLOCKWISE);checkLockdown();break;case KEY.Q:game.spin(DIRECTION.ANTI_CLOCKWISE);checkLockdown();break;case KEY.C:const holdWorked=game.holdTetro();if(holdWorked){lastFallTime=currentTime}break;case KEY.P:state=STATE.PAUSED;break;case KEY.SPACE:handleMoveData(game.hardDrop());lastFallTime=currentTime;lockdownStarted=false;break}}else if(state==STATE.MENU){switch(keyCode){case ENTER:state=STATE.PLAYING;break}}else if(state==STATE.PAUSED){switch(keyCode){case KEY.P:state=STATE.PLAYING;break;case KEY.R:newGame();break}}else if(state==STATE.GAME_OVER){switch(keyCode){case KEY.R:newGame();break}}return returnVal}function keyReleased(){const autoRepeatKeys=[KEY.A,KEY.D,LEFT_ARROW,RIGHT_ARROW];switch(keyCode){case KEY.A:case LEFT_ARROW:autoRepeatEnd(DIRECTION.LEFT);break;case KEY.S:case DOWN_ARROW:game.softDropping=false;break;case KEY.D:case RIGHT_ARROW:autoRepeatEnd(DIRECTION.RIGHT);break}}function handleMoveData(moveData){if(moveData){const{move:move,rows:rows,backToBack:backToBack}=moveData;const moveName=["","T-Spin ","T-Spin Mini "][move];const rowName=["","Single","Double","Triple","Tetris"][rows];let string=`${backToBack?"Back to Back":""} ${moveName}${rowName}`.trim();if(string!=""){lastMove=string}}}function checkLockdown(){if(lockdownStarted){lockdownTimer=0;++lockdownCounter}else if(game.isPieceOnSurface()){lockdownStarted=true;lockdownCounter=0;lockdownTimer=0;lockdownRow=game.activeTetro.pos.row}}function autoRepeat(time){const direction=autoRepeats[0];if(direction){const timeSinceKeyHeld=time-autoRepeatStartTime;if(timeSinceKeyHeld>=AUTO_REPEAT_DELAY){const timeSinceLastRepeat=time-lastAutoRepeatTime;if(timeSinceLastRepeat>=AUTO_REPEAT_FREQ){lastAutoRepeatTime=time;game.move(direction)}}}}function autoRepeatEnd(direction){autoRepeats.splice(autoRepeats.lastIndexOf(direction),1);if(autoRepeats.length!=0){game.move(autoRepeats[autoRepeats.length-1])}autoRepeatStartTime=currentTime}function newGame(){game=new Game;state=STATE.PLAYING;displayScore=0}function drawGame(){background("#222229");drawBoard();drawTetroOnBoard(game.activeTetro.grid,game.activeTetro.tetro.colour,game.activeTetro.pos.row,game.activeTetro.pos.col);drawGhostPiece();fill(160);textSize(75);drawNext();drawHold();drawGameInfo()}function drawBoard(){push();strokeWeight(2);for(let rowNum=BUFFER_ZONE_HEIGHT;rowNum<BOARD_HEIGHT;++rowNum){const row=game.board[rowNum];row.forEach((cell,colNum)=>{if(cell!=0){fill(Object.values(COLOUR)[cell])}else{fill(COLOUR.NIGHT)}rect(LEFT_MARGIN+colNum*CELL_SIZE,(rowNum-BUFFER_ZONE_HEIGHT)*CELL_SIZE,CELL_SIZE,CELL_SIZE)})}pop()}function drawTetroOnBoard(tetroGrid,colour,rowPos,colPos){drawTetro(tetroGrid,colour,LEFT_MARGIN+colPos*CELL_SIZE,CELL_SIZE*(rowPos-BUFFER_ZONE_HEIGHT))}function drawTetro(grid,colour,xPos,yPos,scale=1){const size=CELL_SIZE*scale;push();strokeWeight(3);fill(colour);gridForEach(grid,(cell,rowNum,colNum)=>{if(cell){rect(xPos+colNum*size,yPos+rowNum*size,size,size)}});pop()}function drawNext(){text("Next",570,40);game.next.forEach((tetro,queuePos)=>{const grid=tetro.rotations[0];const rowPos=70+queuePos*3*CELL_SIZE;drawTetro(grid,tetro.colour,570,rowPos)})}function drawHold(){const hold=game.holdSlot;text("Hold",80,40);if(hold){drawTetro(hold.rotations[0],hold.colour,80,70)}}function drawGhostPiece(){const pos=game.activeTetro.pos;const colour=game.activeTetro.tetro.colour.concat(40);drawTetroOnBoard(game.activeTetro.grid,colour,game.activeTetro.pos.row+game.ghostOffset,game.activeTetro.pos.col)}function drawMenu(){background(COLOUR.NIGHT);fill(160);textSize(100);text("Webtris",280,100);textSize(50);text("Controls",150,220);textSize(32);text("Move tetro: A/D or LEFT/RIGHT arrows",150,260);text("Spin tetro: Q/E or UP arrow",150,285);text("Hold: C",150,310);text("Instant drop: SPACE",150,335);text("Pause/resume: P",150,360);textSize(35);text("Press ENTER to start",270,500)}function drawPauseMenu(){fill(COLOUR.ORANGE);strokeWeight(0);fill(160);textSize(LARGE);text("Paused",335,150);textSize(MEDIUM);text("P: Unpause",270,200);text("R: Restart",270,230)}function drawEndScreen(){fill(160);textSize(LARGE);text("Game Over",305,150);textSize(MEDIUM);text("Press R to restart",300,200)}function drawGameInfo(){const leftPos=20;let topPos=160;strokeWeight(0);fill(160);textSize(SMALL);text(`Score:`,leftPos,topPos);textSize(LARGE);text(`${displayScore}`,leftPos+20,topPos+40);textSize(SMALL);text(`Level: ${game.level}`,leftPos,topPos+70);text(`Goal: ${game.goal-game.stats.rowsCleared}`,leftPos,topPos+100);topPos+=130;text(`Lines: ${game.stats.rowsCleared}`,leftPos,topPos+30);text(`Tetrises: ${game.stats.tetrises}`,leftPos,topPos+60);text(`T-Spins: ${game.stats.tSpins}`,leftPos,topPos+90);text(`T-Spin Minis: ${game.stats.tSpinMinis}`,leftPos,topPos+120);text(`: ${lastMove}`,leftPos-15,topPos+170)}